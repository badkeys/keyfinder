#!/usr/bin/python3

import argparse
import datetime
import hashlib
import os
import re
import sys
import urllib.parse
import warnings

import bs4
import requests
import urllib3
from cryptography.hazmat.primitives import serialization

rex_t = r"-----BEGIN[A-Z ]* PRIVATE KEY-----.*?-----END[A-Z ]* PRIVATE KEY-----"
rex = re.compile(rex_t, flags=re.MULTILINE | re.DOTALL)
# rex_b = b"-----BEGIN[A-Z ]* PRIVATE KEY-----.*?-----END[A-Z ]* PRIVATE KEY-----"
# rex = re.compile(rex_b, flags=re.MULTILINE | re.DOTALL)

dups = set()
pdups = set()


def filter_none(inkey):
    return inkey


# un-escape escaped chars like \n
def filter_unesc(inkey):
    return inkey.encode().decode("unicode_escape")


def filter_unesc_multi(inkey):
    old = ""
    unesc = inkey
    while "\\" in unesc and unesc != old:
        old = unesc
        unesc = unesc.encode().decode("unicode_escape")
    return unesc


def filter_html(inkey):
    html = bs4.BeautifulSoup(inkey, "lxml")
    return html.get_text()


# Filter characters that should not appear in a PEM structure
# and spaces at beginning and end of lines.
# (Could make sense to always apply this after other filters...?)
def filter_nopem(inkey):
    key = re.sub(r"[^0-9A-Za-z \n=+/-]", "", inkey)
    key = re.sub(r"^ *", "", key, flags=re.MULTILINE)
    return re.sub(r" *$", "", key, flags=re.MULTILINE)


def filter_unesc_nopem(inkey):
    key = filter_unesc_multi(inkey)
    return filter_nopem(key)


kfilters = [
    filter_none,
    filter_unesc,
    filter_unesc_multi,
    filter_html,
    filter_nopem,
    filter_unesc_nopem,
]


def findkeys(data):
    pkeys = rex.findall(data.decode(errors="ignore"))
    ckeys = []
    for pkey in pkeys:
        ckey = None
        for kfilter in kfilters:
            try:
                bkey = kfilter(pkey).encode()
                ckey = serialization.load_pem_private_key(bkey, password=None)
            # ValueError: various key parsing issues
            # TypeError: missing password
            except (ValueError, TypeError):
                continue
            ckeys.append(ckey)
            break
        if not ckey:
            if args.parseerr:
                phash = hashlib.sha256(pkey.encode()).hexdigest()
                if phash not in pdups:
                    pdups.add(phash)
                    fn = f"{args.parseerr}/{phash}"
                    with open(fn, "w") as f:
                        f.write(pkey)
                    if args.verbose:
                        print(f"Wrote unparsable candidate to {fn}")
                elif args.verbose:
                    print("Found unparsable candidate (duplicate)")
            elif args.verbose:
                print("Found unparsable candidate")

    akeys = []
    for ckey in ckeys:
        spki = ckey.public_key().public_bytes(
            encoding=serialization.Encoding.DER,
            format=serialization.PublicFormat.SubjectPublicKeyInfo,
        )
        spkisha256 = hashlib.sha256(spki).hexdigest()
        if spkisha256 in dups:
            if args.verbose:
                print(f"Duplicate {spkisha256}")
            continue
        dups.add(spkisha256)
        if args.verbose:
            print(f"Found key {spkisha256}")
        try:
            xkey = ckey.private_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PrivateFormat.TraditionalOpenSSL,
                encryption_algorithm=serialization.NoEncryption(),
            )
        except ValueError:
            xkey = ckey.private_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PrivateFormat.PKCS8,
                encryption_algorithm=serialization.NoEncryption(),
            )
        akeys.append(xkey.decode())
    return akeys


def writekey(key, fn, path):
    if os.path.exists(f"{path}/{fn}.key"):
        c = 0
        while True:
            if not os.path.exists(f"{path}/{fn}.{c}.key"):
                fn = f"{fn}.{c}"
                break
            c += 1
    fn += ".key"
    with open(f"{path}/{fn}", "w") as f:
        f.write(key)


if __name__ == "__main__":
    ap = argparse.ArgumentParser()
    ap.add_argument("input", nargs="+")
    ap.add_argument("-o", "--outdir", required=True)
    ap.add_argument("-p", "--parseerr", help="Output dir for unparsable candidates")
    ap.add_argument("-u", "--url", action="store_true", help="URL instead of dir")
    ap.add_argument("-v", "--verbose", action="store_true")
    args = ap.parse_args()

    # Prevents BeautifulSoup warnings, e.g., when content only
    # contains a single URL or a filename.
    warnings.filterwarnings("ignore", category=bs4.MarkupResemblesLocatorWarning)
    # Disable TLS certificate verification warning.
    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

    if args.url:
        for url in args.input:
            host = urllib.parse.urlparse(url).netloc
            today = datetime.datetime.now(tz=datetime.timezone.utc).date().isoformat()
            meta = f"url: {url}\ndate: {today}\n\n"
            r = requests.get(url, timeout=60, verify=False)
            keys = findkeys(r.content)
            for k in keys:
                writekey(meta + k, host, args.outdir)
        sys.exit(0)

    for path in args.input:
        for root, _, files in os.walk(path):
            for fn in files:
                with open(f"{root}/{fn}", "rb") as f:
                    content = f.read()
                keys = findkeys(content)
                for k in keys:
                    ofn = fn
                    if ofn.endswith(".key"):
                        ofn = ofn[0:-4]
                    writekey(k, ofn, args.outdir)
