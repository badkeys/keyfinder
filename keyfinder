#!/usr/bin/python3

import argparse
import os
import re
import sys
import urllib.parse
import warnings

import bs4
import requests
from cryptography.hazmat.primitives import serialization

rex_t = r"-----BEGIN[A-Z ]* PRIVATE KEY-----.*?-----END[A-Z ]* PRIVATE KEY-----"
rex = re.compile(rex_t, flags=re.MULTILINE | re.DOTALL)
# rex_b = b"-----BEGIN[A-Z ]* PRIVATE KEY-----.*?-----END[A-Z ]* PRIVATE KEY-----"
# rex = re.compile(rex_b, flags=re.MULTILINE | re.DOTALL)


def filter_none(inkey):
    return inkey


# un-escape escaped chars like \n
def filter_unesc(inkey):
    return inkey.encode().decode("unicode_escape")


def filter_html(inkey):
    html = bs4.BeautifulSoup(inkey, "lxml")
    return html.get_text()


kfilters = [filter_none, filter_unesc, filter_html]


def findkeys(data):
    pkeys = rex.findall(data.decode(errors="ignore"))
    ckeys = []
    for pkey in pkeys:
        for kfilter in kfilters:
            try:
                bkey = kfilter(pkey).encode()
                ckey = serialization.load_pem_private_key(bkey, password=None)
            except ValueError:
                continue
            ckeys.append(ckey)
            break

    akeys = []
    for ckey in ckeys:
        try:
            xkey = ckey.private_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PrivateFormat.TraditionalOpenSSL,
                encryption_algorithm=serialization.NoEncryption(),
            )
        except ValueError:
            xkey = ckey.private_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PrivateFormat.PKCS8,
                encryption_algorithm=serialization.NoEncryption(),
            )
        akeys.append(xkey.decode())
    return akeys


def writekey(key, fn, path):
    if os.path.exists(f"{path}/{fn}.key"):
        c = 0
        while True:
            if not os.path.exists(f"{path}/{fn}.{c}.key"):
                fn = f"{fn}.{c}"
                break
            c += 1
    fn += ".key"
    with open(f"{path}/{fn}", "w") as f:
        f.write(key)


if __name__ == "__main__":
    ap = argparse.ArgumentParser()
    ap.add_argument("input", nargs="+")
    ap.add_argument("-o", "--outdir", required=True)
    ap.add_argument("-u", "--url", action="store_true", help="URL instead of dir")
    args = ap.parse_args()

    # Prevents BeautifulSoup warnings, e.g., when content only
    # contains a single URL or a filename.
    warnings.filterwarnings("ignore", category=bs4.MarkupResemblesLocatorWarning)

    if args.url:
        for url in args.input:
            host = urllib.parse.urlparse(url).netloc
            r = requests.get(url, timeout=60)
            keys = findkeys(r.content)
            for k in keys:
                writekey(k, host, args.outdir)
        sys.exit(0)

    for path in args.input:
        for root, _, files in os.walk(path):
            for fn in files:
                with open(root + fn, "rb") as f:
                    content = f.read()
                keys = findkeys(content)
                for k in keys:
                    ofn = fn
                    if ofn.endswith(".key"):
                        ofn = ofn[0:-4]
                    writekey(k, ofn, args.outdir)
